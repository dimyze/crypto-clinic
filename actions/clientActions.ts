import { redirect } from "next/navigation";
import {
  addUserToDb,
  setClientHMAC,
  verifyHMACs,
  createHMAC,
  getDifficulty,
  getLastBlock,
  addBlockToBlockchainWithData,
} from "./serverActions";
import { createKeyFromPassword, createIvFromUsername } from "@/utils/utils";
import {
  createCipheriv,
  createDecipheriv,
  createHmac,
  randomBytes,
  createHash,
} from "crypto";
import { signInWithJwt } from "./serverActions";

interface User {
  privateKey: string;
  username: string;
}

interface PatientInformationData {
  fullName: string;
  dateOfBirth: string;
  gender: string;
  contactNumber: string;
  emergencyContactNumber: string;
  medicalRecordNumber: number;
}

interface MedicalHistoryData {
  pastConditions: string;
  surgicalProcedures: string;
  allergies: string;
  familyHistory: string;
}

interface MedicationObservationsData {
  medicationAndDosage: string;
  prescribingPhysician: string;
  physicalExamination: string;
  testResults: string;
}

interface Block {
  patientInformationData: PatientInformationData;
  medicalHistoryData: MedicalHistoryData;
  medicationObservationsData: MedicationObservationsData;
  timestamp: number;
  username: string;
}

export const createUser = async (
  prevState: User,
  formData: FormData
): Promise<User> => {
  const user = await addUserToDb(String(formData.get("username")));
  if (!user) {
    return { username: "", privateKey: "" };
  }
  const cipherPrivateKey = createCipheriv(
    "aes-128-cbc",
    createKeyFromPassword(String(formData.get("password"))),
    createIvFromUsername(String(`$${formData.get("username")}$`))
  );
  const encryptedPrivateKey = Buffer.concat([
    cipherPrivateKey.update(user.privateKey),
    cipherPrivateKey.final(),
  ]);

  return {
    privateKey: encryptedPrivateKey.toString("hex"),
    username: user.username,
  };
};

export const redirectToSignIn = (data: FormData) => {
  redirect("/auth/signin");
};

export const signInUser = async (prevState: string, formData: FormData) => {
  const privateKey = formData.get("privateKey");
  let userData = String(
    window.localStorage.getItem(String(formData.get("username")))
  );
  if (userData === "null" && privateKey === null) {
    return "unregistered";
  } else if (userData === "null" && privateKey !== null) {
    userData = JSON.stringify({
      privateKey,
      username: formData.get("username"),
    });
  }
  const parsedUserData = JSON.parse(userData);
  const decipherPrivateKey = createDecipheriv(
    "aes-128-cbc",
    createKeyFromPassword(String(formData.get("password"))),
    createIvFromUsername(String(`$${formData.get("username")}$`))
  );

  try {
    const decryptedPrivateKey = Buffer.concat([
      decipherPrivateKey.update(Buffer.from(parsedUserData.privateKey, "hex")),
      decipherPrivateKey.final(),
    ]).toString("utf-8");
    const result = await startHmacVerification(
      String(formData.get("username")),
      decryptedPrivateKey
    );
    if (result === "incorrect-private-key") {
      return result;
    }
    window.localStorage.setItem(String(formData.get("username")), userData);
    await signInWithJwt(String(formData.get("username")));
    return `success-${String(formData.get("username"))}`;
  } catch (error) {
    console.log(error);
    return "incorrect-password";
  }
};

export const startHmacVerification = async (
  payload: string,
  privateKey: string
) => {
  console.log("Started HMAC Verification");
  const randomChallenge = randomBytes(20).toString("hex");
  console.log("Random Challenge generated by client: ", randomChallenge);
  const { hmacDocServerLocation, randomString } = await createHMAC(
    randomChallenge,
    payload
  );
  console.log("Random string received from server: ", randomString);
  const hmac = createHmac("sha256", privateKey)
    .update(randomChallenge + randomString)
    .digest("hex");
  console.log("HMAC generated by client: ", hmac);
  const hmacDocClientLocation = randomBytes(32).toString("hex");
  await setClientHMAC(hmac, hmacDocClientLocation);
  const sameHMACs = await verifyHMACs(
    hmacDocServerLocation,
    hmacDocClientLocation
  );
  if (!sameHMACs) {
    console.log("HMAC verification failed!");
    return "incorrect-private-key";
  } else {
    console.log("HMAC verification successful!");
    return "success";
  }
};

export const createBlock = (
  patientInformationData: PatientInformationData,
  medicalHistoryData: MedicalHistoryData,
  medicationObservationsData: MedicationObservationsData,
  username: string
) => {
  const block: Block = {
    patientInformationData,
    medicalHistoryData,
    medicationObservationsData,
    timestamp: Date.now(),
    username,
  };
  return block;
};

export const verifyTransaction = async (
  username: string,
  privateKey: string
) => {
  const result = await startHmacVerification(username, privateKey);
  return result;
};

export const mineBlock = async (block: Block) => {
  const { username, timestamp } = block;
  const difficulty = await getDifficulty();
  const prevHash: string = (await getLastBlock())?.hash;
  const targetArray: string[] = [];
  for (let i = 0; i < difficulty; i++) {
    targetArray.push("0");
  }
  const target = targetArray.join("");
  let nonce = 0;
  let hash = createHash("sha256")
    .update(JSON.stringify(block) + prevHash + timestamp + nonce)
    .digest("hex");
  nonce++;
  while (hash.slice(0, difficulty) !== target) {
    hash = createHash("sha256")
      .update(JSON.stringify(block) + prevHash + timestamp + nonce)
      .digest("hex");
    nonce++;
  }
  const blockchainBlock = {
    prevHash,
    hash,
    timestamp,
    username,
  };
  const blockWithHash = { ...block, hash };
  console.log("Adding data to blockchain");
  await addBlockToBlockchainWithData(blockchainBlock, blockWithHash);
  console.log("Blockchain updated!");
  return [hash, difficulty, timestamp];
};
